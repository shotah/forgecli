
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>forgecli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shotah/forgecli/forgecli/curseforgeapi.go (73.2%)</option>
				
				<option value="file1">github.com/shotah/forgecli/forgecli/fabricapi.go (54.8%)</option>
				
				<option value="file2">github.com/shotah/forgecli/forgecli/forgecli.go (35.3%)</option>
				
				<option value="file3">github.com/shotah/forgecli/forgecli/helpers.go (60.7%)</option>
				
				<option value="file4">github.com/shotah/forgecli/forgecli/minecraftapi.go (93.3%)</option>
				
				<option value="file5">github.com/shotah/forgecli/forgecli/mocks.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package forgecli is main cli
package forgecli

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/sirupsen/logrus"
)

func (app *appEnv) SetForgeAPIKey() error <span class="cov8" title="1">{
        if app.forgeKey != "" </span><span class="cov8" title="1">{
                logrus.Debug("forgeKey Provided")
                return nil
        }</span>
        <span class="cov8" title="1">if os.Getenv("FORGEKEY") != "" </span><span class="cov8" title="1">{
                app.forgeKey = os.Getenv("FORGEKEY")
                logrus.Debug("forgeKey found in FORGEKEY")
                return nil
        }</span>
        <span class="cov8" title="1">if os.Getenv("MODS_FORGEAPI_KEY") != "" </span><span class="cov8" title="1">{
                app.forgeKey = os.Getenv("MODS_FORGEAPI_KEY")
                logrus.Debug("forgeKey found in MODS_FORGEAPI_KEY")
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("MISSING a required field: forgeKey")</span>
}

func (app *appEnv) GetModsByProjectIDs() error <span class="cov8" title="1">{
        if app.projectIDs == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">projectIDs := strings.Split(app.projectIDs, ",")
        for _, projectID := range projectIDs </span><span class="cov8" title="1">{
                var convertedJSONMod JSONMod
                convertedJSONMod.ProjectID = projectID
                logrus.Debugf("Getting Mod: %s", convertedJSONMod.ProjectID)
                if err := app.GetModsFromForge(convertedJSONMod, app.modReleaseType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (app *appEnv) GetModsByJSONFile() error <span class="cov8" title="1">{
        if app.jsonFile == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">logrus.Debugf("Getting Mods: %s", app.modsFromJSON)
        var releaseType ReleaseType
        for _, fileMod := range app.modsFromJSON </span><span class="cov8" title="1">{
                logrus.Debugf("Getting Mod: %s", fileMod.ProjectID)
                if fileMod.ReleaseType != "" </span><span class="cov8" title="1">{
                        releaseType = releaseLookup[fileMod.ReleaseType]
                }</span> else<span class="cov0" title="0"> {
                        releaseType = app.modReleaseType
                }</span>
                <span class="cov8" title="1">logrus.Debugf("Getting Mod releaseType: %v", releaseType)
                if err := app.GetModsFromForge(fileMod, releaseType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (app *appEnv) GetModsDependencies() error <span class="cov0" title="0">{
        if !app.downloadDependencies </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, mod := range app.modsToDownload </span><span class="cov0" title="0">{
                for _, modDep := range mod.Dependencies </span><span class="cov0" title="0">{
                        if modDep.RelationType == 3 </span><span class="cov0" title="0">{
                                var convertedJSONMod JSONMod
                                convertedJSONMod.ProjectID = strconv.Itoa(modDep.ModID)
                                logrus.Debugf("Getting Mod dependency: %s", convertedJSONMod.ProjectID)
                                if err := app.GetModsFromForge(convertedJSONMod, releaseLookup["release"]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (app *appEnv) GetModsFromForge(modToGet JSONMod, _ ReleaseType) error <span class="cov8" title="1">{
        var resp ForgeMods
        pageIndex := 0
        pageSize := 999
        url := fmt.Sprintf(
                "https://api.curseforge.com/v1/mods/%s/files?gameVersionTypeID=%d&amp;index=%d&amp;pageSize=%d",
                modToGet.ProjectID, app.forgeGameVersionType, pageIndex, pageSize,
        )
        if err := app.FetchForgeAPIJSON(url, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // logrus.Debugf("Response from forge: %v", resp.Data)

        <span class="cov8" title="1">foundID := 0
        var foundMod ForgeMod
        for _, currMod := range resp.Data </span><span class="cov8" title="1">{
                if currMod.ID &gt; foundID &amp;&amp; app.ModFilter(currMod, modToGet) </span><span class="cov8" title="1">{
                        logrus.Debugf("Found mod: %d", currMod.ID)
                        foundID = currMod.ID
                        foundMod = currMod
                }</span>
        }
        <span class="cov8" title="1">if foundID == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find %s for minecraft version: %s or family: %s", modToGet.ProjectID, app.version, app.modfamily)
        }</span>
        <span class="cov8" title="1">logrus.Debugf("Found mod: %v", foundMod)
        app.modsToDownload[foundID] = foundMod
        logrus.Infof("Found Latest FileID: %d for Mod: %s", foundID, modToGet.ProjectID)
        return nil</span>
}

func (app *appEnv) ModFamilyFilter(currMod ForgeMod) bool <span class="cov8" title="1">{
        // Apply mod family filter
        if app.modfamily != "" </span><span class="cov8" title="1">{
                result := contains(currMod.GameVersions, string(app.modfamily))
                logrus.Debugf("Mod's family Filter Result: %t", result)
                return result
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (app *appEnv) ModVersionFilter(currMod ForgeMod, modToGet JSONMod) bool <span class="cov8" title="1">{
        // Apply Version filter
        modVersion := app.version
        if modToGet.Version != "" </span><span class="cov0" title="0">{
                modVersion = modToGet.Version
        }</span>
        <span class="cov8" title="1">logrus.Debugf("Mod's Game Version Filters: \n%s \n%s", currMod.GameVersions, string(modVersion))
        result := contains(currMod.GameVersions, string(modVersion))
        logrus.Debugf("Mod's Game Version Filter Result: %t", result)
        return result</span>
}

func (app *appEnv) ModFilter(currMod ForgeMod, modToGet JSONMod) bool <span class="cov8" title="1">{
        // Filtering on Filename Only
        if modToGet.Filename != "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return app.ModFamilyFilter(currMod) &amp;&amp; app.ModVersionFilter(currMod, modToGet)</span>
}

func (app *appEnv) GetVersionTypeNumber() error <span class="cov8" title="1">{
        // Forge has a specific format to validate Minecraft 1.17
        shortNumber := strings.Join(strings.Split(app.version, ".")[:2], ".")
        forgeVersionName := "Minecraft " + shortNumber
        logrus.Debugf("Fetching VersionType for MC version: %s, %s", forgeVersionName, ForgeVersionTypeURL)

        var resp ForgeVersions
        if err := app.FetchForgeAPIJSON(ForgeVersionTypeURL, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, v := range resp.Data </span><span class="cov8" title="1">{
                if v.Name == forgeVersionName </span><span class="cov8" title="1">{
                        app.forgeGameVersionType = v.ID
                        logrus.Debugf("found VersionType: %d", v.ID)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">app.forgeGameVersionType = 0
        return fmt.Errorf("could not find forge version for:%s", forgeVersionName)</span>
}

func (app *appEnv) DownloadMods() error <span class="cov0" title="0">{
        for _, mod := range app.modsToDownload </span><span class="cov0" title="0">{
                if err := app.FetchAndSave(mod.DownloadURL, mod.Filename, app.destination); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package forgecli is main cli
package forgecli

import (
        "fmt"
        "os"
        "os/exec"

        "github.com/sirupsen/logrus"
)

// FabricAPIBaseURL Base Forge API URL
// Example: `https://maven.fabricmc.net/net/fabricmc/fabric-installer/0.11.1/fabric-installer-0.11.1.jar`
const FabricAPIBaseURL = "https://maven.fabricmc.net/net/fabricmc/fabric-installer/"

func (app *appEnv) FabricClientInstallerVersion() error <span class="cov8" title="1">{
        if app.clientInstallerVersion != "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var fabricXMLResponse XMLFabric
        if err := app.FetchXML(FabricMetadataURL, &amp;fabricXMLResponse); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not get fabric version from:\n%s", FabricMetadataURL)
        }</span>
        <span class="cov8" title="1">app.clientInstallerVersion = fabricXMLResponse.Versioning.Latest
        return nil</span>
}

func (app *appEnv) FabricClientDownload() error <span class="cov8" title="1">{
        logrus.Debug("FabricClientDownload")
        app.FabricClientInstallerVersion()
        app.clientInstallerFileName = fmt.Sprintf("fabric-installer-%s.jar", app.clientInstallerVersion)
        clientDownloadURL := FabricAPIBaseURL + app.clientInstallerVersion + "/" + app.clientInstallerFileName
        logrus.Debugf("FabricClientDownload: URL: %s", clientDownloadURL)
        // download the client where you are running the code from:
        err := app.FetchAndSave(clientDownloadURL, app.clientInstallerFileName, ".")
        return err
}</span>

func (app *appEnv) FabricClientRemoval() error <span class="cov8" title="1">{
        // Validates file is downloaded
        filePath := "./" + app.clientInstallerFileName
        _, err := os.Stat(filePath)
        if err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logrus.Debugf("Removing file: %s", filePath)
        return os.Remove(filePath)</span>
}

func (app *appEnv) FabricClientInstaller() error <span class="cov0" title="0">{
        app.FabricClientDownload()
        installCommands := []string{"-jar", app.clientInstallerFileName, "client"}
        if app.version != "" </span><span class="cov0" title="0">{
                installCommands = []string{"-jar", app.clientInstallerFileName, "client", "-mcversion", app.version}
        }</span>
        <span class="cov0" title="0">logrus.Debugf("java %v", installCommands)
        clientInstall, err := exec.Command("java", installCommands...).CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("fabric client install failed: %s", err)
        }</span>
        <span class="cov0" title="0">logrus.Debugf("Install Output: %s", clientInstall)
        app.FabricClientRemoval()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package forgecli

import (
        "flag"
        "fmt"
        "net/http"
        "os"
        "os/exec"

        "github.com/sirupsen/logrus"
)

type appEnv struct {
        hc                      http.Client
        jsonFile                string
        forgeKey                string
        version                 string
        clientInstaller         bool
        projectIDs              string
        downloadDependencies    bool
        clearMods               bool
        modfamily               FamilyType
        modReleaseType          ReleaseType
        destination             string
        modsFromJSON            JSONMods
        forgeGameVersionType    int
        modsToDownload          map[int]ForgeMod
        clientInstallerVersion  string
        clientInstallerFileName string
        isDebug                 bool
}

// CLI Main Module Entrypoint
func CLI(args []string) int <span class="cov8" title="1">{
        var app appEnv
        err := app.fromArgs(args)
        if err != nil </span><span class="cov8" title="1">{
                return 2
        }</span>
        <span class="cov0" title="0">if err := app.run(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Runtime error: %v\n", err)
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (app *appEnv) fromArgs(args []string) error <span class="cov8" title="1">{
        // Shallow copy of default client
        app.hc = *http.DefaultClient
        app.modsToDownload = make(map[int]ForgeMod)

        fl := flag.NewFlagSet("forgecli", flag.ContinueOnError)
        fl.StringVar(&amp;app.jsonFile, "file", "", "file json with required mods and settings")
        fl.StringVar(&amp;app.forgeKey, "forgekey", "", "ForgeAPIKey used in Authentication with the Forge API")
        fl.StringVar(&amp;app.destination, "destination", "", "destination directory for mods")
        fl.StringVar(&amp;app.version, "version", "", "Minecraft version you are installing")
        fl.BoolVar(&amp;app.clientInstaller, "client", false, "Downloads and installs Client based on Family (if no family, no client install will be done)")
        fl.BoolVar(&amp;app.downloadDependencies, "dependencies", true, "Download Mods Dependencies")
        fl.BoolVar(&amp;app.clearMods, "clear", false, "Clear Mods from destination (mods folder)")
        fl.BoolVar(&amp;app.isDebug, "debug", false, "enable debug logging")
        fl.StringVar(&amp;app.projectIDs, "projects", "", "Forge Project IDs separated by commas 12345,67890")
        inputReleaseType := fl.String("release", "release", "Mods release type, release, beta, alpha")
        inputFamily := fl.String("family", "", "Minecraft type: Fabric, Forge, Bukkit")

        // Parsing the Args before they can be used
        if err := fl.Parse(args); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Type Conversions
        <span class="cov0" title="0">app.modReleaseType = releaseLookup[*inputReleaseType]
        if len(*inputFamily) &gt; 0 </span><span class="cov0" title="0">{
                app.modfamily = familyTypeLookup[*inputFamily]
        }</span>

        // Setting up logrus
        <span class="cov0" title="0">if app.isDebug </span><span class="cov0" title="0">{
                logrus.SetLevel(logrus.DebugLevel)
        }</span>

        // Checking for Required Fields
        <span class="cov0" title="0">if app.projectIDs == "" &amp;&amp; app.jsonFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Did not receive Project IDs to Download.\n")
                fl.Usage()
                return flag.ErrHelp
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (app *appEnv) run() error <span class="cov0" title="0">{
        logrus.Info("Starting Forge Mod Lookup")
        app.SetForgeAPIKey()

        app.GetMCVersion()
        logrus.Debugf("Using Minecraft Version: %s", app.version)

        app.GetVersionTypeNumber()
        logrus.Debugf("Using Forge VersionType: %d", app.forgeGameVersionType)

        app.GetModsByProjectIDs()
        app.LoadModsFromJSON()
        app.GetModsByJSONFile()

        app.GetModsDependencies()

        app.PrepareDestinationFolder()
        app.DownloadMods()
        app.PrintDestinationFiles()
        logrus.Info("Mods Download Complete.")

        app.ClientInstaller()
        return nil
}</span>

func (app *appEnv) ValidateJavaInstallation() error <span class="cov8" title="1">{
        javaVersion, err := exec.Command("java", "-version").CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                logrus.Debugln("java version not found")
                return fmt.Errorf("unable to find java, please install and try again")
        }</span>
        <span class="cov8" title="1">logrus.Debugf("java version found: %s", javaVersion)
        return nil</span>
}

// ClientInstaller main handler for the client installations
func (app *appEnv) ClientInstaller() error <span class="cov0" title="0">{
        if !app.clientInstaller </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">logrus.Info("Starting Client Installer")
        // Makes sure their is an instance of Java installed to use for the installation.
        if err := app.ValidateJavaInstallation(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Starts the fabric installation process.
        <span class="cov0" title="0">switch app.modfamily </span>{
        case Fabric:<span class="cov0" title="0">
                if err := app.FabricClientInstaller(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case Forge:<span class="cov0" title="0">
                if err := app.FabricClientInstaller(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">logrus.Info("Finishing Client Installer")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package forgecli

import (
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/user"
        "runtime"
        "strings"

        "github.com/sirupsen/logrus"
)

func contains(s []string, e string) bool <span class="cov8" title="1">{
        for _, a := range s </span><span class="cov8" title="1">{
                if strings.EqualFold(a, e) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (app *appEnv) GetTargetDirectory() error <span class="cov8" title="1">{
        if app.destination != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">user, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">os := runtime.GOOS
        switch os </span>{
        case "windows":<span class="cov8" title="1">
                app.destination = fmt.Sprintf("%s\\AppData\\Roaming\\.minecraft\\mods", user.HomeDir)</span>
        case "darwin":<span class="cov0" title="0">
                app.destination = fmt.Sprintf("%s/Library/Application Support/minecraft/mods", user.HomeDir)</span>
        case "linux":<span class="cov0" title="0">
                app.destination = fmt.Sprintf("%s/Library/Application Support/minecraft/mods", user.HomeDir)</span>
        default:<span class="cov0" title="0">
                if err := fmt.Errorf("%s does not have a default directory, please provide target directory", os); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (app *appEnv) EnsureDestination() error <span class="cov0" title="0">{
        logrus.Debugf("Making Folder if not exist: %s", app.destination)
        err := os.MkdirAll(app.destination, os.ModeDir)
        if err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (app *appEnv) PrepareDestinationFolder() error <span class="cov0" title="0">{
        app.GetTargetDirectory()
        logrus.Debugf("Mod Destination is set to: %s", app.destination)
        if app.clearMods </span><span class="cov0" title="0">{
                logrus.Debugf("Removing contents of: %s", app.destination)
                if err := os.RemoveAll(app.destination); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">app.EnsureDestination()
        return nil</span>
}

func (app *appEnv) FetchForgeAPIJSON(url string, data interface{}) error <span class="cov8" title="1">{
        logrus.Debugf("Fetching: %s", url)
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header = http.Header{
                "Accept":    []string{"application/json"},
                "x-api-key": []string{app.forgeKey},
        }
        resp, err := app.hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        return json.NewDecoder(resp.Body).Decode(data)</span>
}

func (app *appEnv) FetchJSON(url string, data interface{}) error <span class="cov8" title="1">{
        logrus.Debugf("Fetching JSON: %s", url)
        resp, err := app.hc.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        return json.NewDecoder(resp.Body).Decode(data)</span>
}

func (app *appEnv) FetchXML(url string, data interface{}) error <span class="cov8" title="1">{
        logrus.Debugf("Fetching XML: %s", url)
        resp, err := app.hc.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return xml.Unmarshal(respBody, &amp;data)</span>
}

func (app *appEnv) LoadModsFromJSON() error <span class="cov8" title="1">{
        if app.jsonFile == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">logrus.Debugf("Fetching JSON from file: %s", app.jsonFile)
        jsonFile, err := os.Open(app.jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer jsonFile.Close()
        byteValue, _ := io.ReadAll(jsonFile)
        var result JSONMods
        json.Unmarshal([]byte(byteValue), &amp;result)
        logrus.Debugf("Pulled from json file: %s", result)
        app.modsFromJSON = result
        return nil</span>
}

func (app *appEnv) FetchAndSave(url string, fileName string, destPath string) error <span class="cov8" title="1">{
        logrus.Infof("Downloading: %s", url)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header = http.Header{
                "Accept":    []string{"application/json"},
                "x-api-key": []string{app.forgeKey},
        }
        resp, err := app.hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        f, err := os.Create(fmt.Sprintf(destPath + "/" + fileName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        _, err = io.Copy(f, resp.Body)
        return err</span>
}

func (app *appEnv) PrintDestinationFiles() <span class="cov0" title="0">{
        files, err := os.ReadDir(app.destination)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">logrus.Infof("Files in Destination Folder:")
        for _, file := range files </span><span class="cov0" title="0">{
                logrus.Infof("  %s  ", file.Name())
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package forgecli

import "fmt"

// MinecraftVersionURL URL to grab the json manifest
const MinecraftVersionURL = "https://launchermeta.mojang.com/mc/game/version_manifest.json"

// MCLatest Latest release
type MCLatest struct {
        Release  string `json:"release"`
        Snapshot string `json:"snapshot"`
}

// MCVersion Specific Mojang versions
type MCVersion struct {
        ID          string `json:"id"`
        Type        string `json:"type"`
        URL         string `json:"url"`
        Time        string `json:"time"`
        ReleaseTime string `json:"releaseTime"`
}

// MCVersionResponse Default Mojang Version Response
type MCVersionResponse struct {
        Latest   MCLatest    `json:"latest"`
        Versions []MCVersion `json:"versions"`
}

func (app *appEnv) GetMCVersion() error <span class="cov8" title="1">{
        var resp MCVersionResponse
        if err := app.FetchJSON(MinecraftVersionURL, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not get minecraft version from:\n%s", MinecraftVersionURL)
        }</span>
        <span class="cov8" title="1">if app.version == "" </span><span class="cov8" title="1">{
                version := resp.Latest.Release
                app.version = version
                return nil
        }</span>
        <span class="cov8" title="1">inputVersion := app.version
        for _, v := range resp.Versions </span><span class="cov8" title="1">{
                if v.ID == inputVersion </span><span class="cov8" title="1">{
                        returnVersion := v.ID
                        app.version = returnVersion
                        return nil
                }</span>
        }
        <span class="cov8" title="1">app.version = ""
        return fmt.Errorf("could not find minecraft version: %s", inputVersion)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package forgecli

import (
        "os"
        "testing"

        "github.com/h2non/gock"
        "github.com/nbio/st"
)

func MockFabricXML(t *testing.T) <span class="cov8" title="1">{
        mockFile := "./mocks/fabric.xml"
        gock.New("https://maven.fabricmc.net").
                Get("/net/fabricmc/fabric-installer/maven-metadata.xml").
                Reply(200).File(mockFile)
}</span>

func MockFabricJAR(t *testing.T) <span class="cov8" title="1">{
        mockFile := "./mocks/fake.jar"
        gock.New("https://maven.fabricmc.net").
                Get("/net/fabricmc/fabric-installer/0.11.1/fabric-installer-0.11.1.jar").
                Reply(200).File(mockFile)
}</span>

func MockMCVersions(t *testing.T) <span class="cov8" title="1">{
        mockFile := "./mocks/mc_version_manifest.json"
        body, err := os.ReadFile(mockFile)
        st.Expect(t, err, nil)
        gock.New("https://launchermeta.mojang.com").
                Get("/mc/game/version_manifest.json").
                Reply(200).
                JSON(body)
}</span>

func MockCurseForgeVersions(t *testing.T) <span class="cov8" title="1">{
        mockFile := "./mocks/mc_version_types.json"
        body, err := os.ReadFile(mockFile)
        st.Expect(t, err, nil)
        gock.New("https://api.curseforge.com").
                Get("/v1/games/432/version-types").
                Reply(200).
                JSON(body)
}</span>

func MockCurseForgeModResponse(t *testing.T) <span class="cov8" title="1">{
        mockFile := "./mocks/voice_mod_response.json"
        body, err := os.ReadFile(mockFile)
        st.Expect(t, err, nil)
        gock.New("https://api.curseforge.com").
                Get("/v1/mods/416089/files").
                Reply(200).
                JSON(body)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
